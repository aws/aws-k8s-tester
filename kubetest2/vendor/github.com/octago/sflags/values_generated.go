package sflags

// This file is autogenerated by "go generate .". Do not modify.

import (
	"encoding/hex"
	"fmt"
	"net"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func parseGenerated(value interface{}) Value {
	switch value.(type) {
	case *string:
		return newStringValue(value.(*string))
	case *bool:
		return newBoolValue(value.(*bool))
	case *uint:
		return newUintValue(value.(*uint))
	case *uint8:
		return newUint8Value(value.(*uint8))
	case *uint16:
		return newUint16Value(value.(*uint16))
	case *uint32:
		return newUint32Value(value.(*uint32))
	case *uint64:
		return newUint64Value(value.(*uint64))
	case *int:
		return newIntValue(value.(*int))
	case *int8:
		return newInt8Value(value.(*int8))
	case *int16:
		return newInt16Value(value.(*int16))
	case *int32:
		return newInt32Value(value.(*int32))
	case *int64:
		return newInt64Value(value.(*int64))
	case *float64:
		return newFloat64Value(value.(*float64))
	case *float32:
		return newFloat32Value(value.(*float32))
	case *time.Duration:
		return newDurationValue(value.(*time.Duration))
	case *net.IP:
		return newIPValue(value.(*net.IP))
	case *HexBytes:
		return newHexBytesValue(value.(*HexBytes))
	case *net.TCPAddr:
		return newTCPAddrValue(value.(*net.TCPAddr))
	case *net.IPNet:
		return newIPNetValue(value.(*net.IPNet))
	case *[]string:
		return newStringSliceValue(value.(*[]string))
	case *[]bool:
		return newBoolSliceValue(value.(*[]bool))
	case *[]uint:
		return newUintSliceValue(value.(*[]uint))
	case *[]uint8:
		return newUint8SliceValue(value.(*[]uint8))
	case *[]uint16:
		return newUint16SliceValue(value.(*[]uint16))
	case *[]uint32:
		return newUint32SliceValue(value.(*[]uint32))
	case *[]uint64:
		return newUint64SliceValue(value.(*[]uint64))
	case *[]int:
		return newIntSliceValue(value.(*[]int))
	case *[]int8:
		return newInt8SliceValue(value.(*[]int8))
	case *[]int16:
		return newInt16SliceValue(value.(*[]int16))
	case *[]int32:
		return newInt32SliceValue(value.(*[]int32))
	case *[]int64:
		return newInt64SliceValue(value.(*[]int64))
	case *[]float64:
		return newFloat64SliceValue(value.(*[]float64))
	case *[]float32:
		return newFloat32SliceValue(value.(*[]float32))
	case *[]time.Duration:
		return newDurationSliceValue(value.(*[]time.Duration))
	case *[]net.IP:
		return newIPSliceValue(value.(*[]net.IP))
	case *[]HexBytes:
		return newHexBytesSliceValue(value.(*[]HexBytes))
	case *[]*regexp.Regexp:
		return newRegexpSliceValue(value.(*[]*regexp.Regexp))
	case *[]net.TCPAddr:
		return newTCPAddrSliceValue(value.(*[]net.TCPAddr))
	case *[]net.IPNet:
		return newIPNetSliceValue(value.(*[]net.IPNet))
	default:
		return nil
	}
}

func parseGeneratedPtrs(value interface{}) Value {
	switch value.(type) {
	case **regexp.Regexp:
		return newRegexpValue(value.(**regexp.Regexp))
	default:
		return nil
	}
}

// -- string Value
type stringValue struct {
	value *string
}

var _ Value = (*stringValue)(nil)
var _ Getter = (*stringValue)(nil)

func newStringValue(p *string) *stringValue {
	return &stringValue{value: p}
}

func (v *stringValue) Set(s string) error {
	*v.value = s
	return nil
}

func (v *stringValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *stringValue) String() string {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ""
}

func (v *stringValue) Type() string { return "string" }

// -- stringSlice Value

type stringSliceValue struct {
	value   *[]string
	changed bool
}

var _ RepeatableFlag = (*stringSliceValue)(nil)
var _ Value = (*stringSliceValue)(nil)
var _ Getter = (*stringSliceValue)(nil)

func newStringSliceValue(slice *[]string) *stringSliceValue {
	return &stringSliceValue{
		value: slice,
	}
}

func (v *stringSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")
	out := ss
	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *stringSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]string)(nil)
}

func (v *stringSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newStringValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *stringSliceValue) Type() string { return "stringSlice" }

func (v *stringSliceValue) IsCumulative() bool {
	return true
}

// -- bool Value
type boolValue struct {
	value *bool
}

var _ Value = (*boolValue)(nil)
var _ Getter = (*boolValue)(nil)

func newBoolValue(p *bool) *boolValue {
	return &boolValue{value: p}
}

func (v *boolValue) Set(s string) error {
	parsed, err := strconv.ParseBool(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *boolValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *boolValue) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *boolValue) Type() string { return "bool" }

// -- boolSlice Value

type boolSliceValue struct {
	value   *[]bool
	changed bool
}

var _ RepeatableFlag = (*boolSliceValue)(nil)
var _ Value = (*boolSliceValue)(nil)
var _ Getter = (*boolSliceValue)(nil)

func newBoolSliceValue(slice *[]bool) *boolSliceValue {
	return &boolSliceValue{
		value: slice,
	}
}

func (v *boolSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]bool, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *boolSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]bool)(nil)
}

func (v *boolSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newBoolValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *boolSliceValue) Type() string { return "boolSlice" }

func (v *boolSliceValue) IsCumulative() bool {
	return true
}

// -- uint Value
type uintValue struct {
	value *uint
}

var _ Value = (*uintValue)(nil)
var _ Getter = (*uintValue)(nil)

func newUintValue(p *uint) *uintValue {
	return &uintValue{value: p}
}

func (v *uintValue) Set(s string) error {
	parsed, err := strconv.ParseUint(s, 0, 64)
	if err == nil {
		*v.value = (uint)(parsed)
		return nil
	}
	return err
}

func (v *uintValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *uintValue) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *uintValue) Type() string { return "uint" }

// -- uintSlice Value

type uintSliceValue struct {
	value   *[]uint
	changed bool
}

var _ RepeatableFlag = (*uintSliceValue)(nil)
var _ Value = (*uintSliceValue)(nil)
var _ Getter = (*uintSliceValue)(nil)

func newUintSliceValue(slice *[]uint) *uintSliceValue {
	return &uintSliceValue{
		value: slice,
	}
}

func (v *uintSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]uint, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}
		out[i] = (uint)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *uintSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]uint)(nil)
}

func (v *uintSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUintValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *uintSliceValue) Type() string { return "uintSlice" }

func (v *uintSliceValue) IsCumulative() bool {
	return true
}

// -- uint8 Value
type uint8Value struct {
	value *uint8
}

var _ Value = (*uint8Value)(nil)
var _ Getter = (*uint8Value)(nil)

func newUint8Value(p *uint8) *uint8Value {
	return &uint8Value{value: p}
}

func (v *uint8Value) Set(s string) error {
	parsed, err := strconv.ParseUint(s, 0, 8)
	if err == nil {
		*v.value = (uint8)(parsed)
		return nil
	}
	return err
}

func (v *uint8Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *uint8Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *uint8Value) Type() string { return "uint8" }

// -- uint8Slice Value

type uint8SliceValue struct {
	value   *[]uint8
	changed bool
}

var _ RepeatableFlag = (*uint8SliceValue)(nil)
var _ Value = (*uint8SliceValue)(nil)
var _ Getter = (*uint8SliceValue)(nil)

func newUint8SliceValue(slice *[]uint8) *uint8SliceValue {
	return &uint8SliceValue{
		value: slice,
	}
}

func (v *uint8SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]uint8, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}
		out[i] = (uint8)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *uint8SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]uint8)(nil)
}

func (v *uint8SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint8Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint8SliceValue) Type() string { return "uint8Slice" }

func (v *uint8SliceValue) IsCumulative() bool {
	return true
}

// -- uint16 Value
type uint16Value struct {
	value *uint16
}

var _ Value = (*uint16Value)(nil)
var _ Getter = (*uint16Value)(nil)

func newUint16Value(p *uint16) *uint16Value {
	return &uint16Value{value: p}
}

func (v *uint16Value) Set(s string) error {
	parsed, err := strconv.ParseUint(s, 0, 16)
	if err == nil {
		*v.value = (uint16)(parsed)
		return nil
	}
	return err
}

func (v *uint16Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *uint16Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *uint16Value) Type() string { return "uint16" }

// -- uint16Slice Value

type uint16SliceValue struct {
	value   *[]uint16
	changed bool
}

var _ RepeatableFlag = (*uint16SliceValue)(nil)
var _ Value = (*uint16SliceValue)(nil)
var _ Getter = (*uint16SliceValue)(nil)

func newUint16SliceValue(slice *[]uint16) *uint16SliceValue {
	return &uint16SliceValue{
		value: slice,
	}
}

func (v *uint16SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]uint16, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}
		out[i] = (uint16)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *uint16SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]uint16)(nil)
}

func (v *uint16SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint16Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint16SliceValue) Type() string { return "uint16Slice" }

func (v *uint16SliceValue) IsCumulative() bool {
	return true
}

// -- uint32 Value
type uint32Value struct {
	value *uint32
}

var _ Value = (*uint32Value)(nil)
var _ Getter = (*uint32Value)(nil)

func newUint32Value(p *uint32) *uint32Value {
	return &uint32Value{value: p}
}

func (v *uint32Value) Set(s string) error {
	parsed, err := strconv.ParseUint(s, 0, 32)
	if err == nil {
		*v.value = (uint32)(parsed)
		return nil
	}
	return err
}

func (v *uint32Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *uint32Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *uint32Value) Type() string { return "uint32" }

// -- uint32Slice Value

type uint32SliceValue struct {
	value   *[]uint32
	changed bool
}

var _ RepeatableFlag = (*uint32SliceValue)(nil)
var _ Value = (*uint32SliceValue)(nil)
var _ Getter = (*uint32SliceValue)(nil)

func newUint32SliceValue(slice *[]uint32) *uint32SliceValue {
	return &uint32SliceValue{
		value: slice,
	}
}

func (v *uint32SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]uint32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}
		out[i] = (uint32)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *uint32SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]uint32)(nil)
}

func (v *uint32SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint32Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint32SliceValue) Type() string { return "uint32Slice" }

func (v *uint32SliceValue) IsCumulative() bool {
	return true
}

// -- uint64 Value
type uint64Value struct {
	value *uint64
}

var _ Value = (*uint64Value)(nil)
var _ Getter = (*uint64Value)(nil)

func newUint64Value(p *uint64) *uint64Value {
	return &uint64Value{value: p}
}

func (v *uint64Value) Set(s string) error {
	parsed, err := strconv.ParseUint(s, 0, 64)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *uint64Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *uint64Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *uint64Value) Type() string { return "uint64" }

// -- uint64Slice Value

type uint64SliceValue struct {
	value   *[]uint64
	changed bool
}

var _ RepeatableFlag = (*uint64SliceValue)(nil)
var _ Value = (*uint64SliceValue)(nil)
var _ Getter = (*uint64SliceValue)(nil)

func newUint64SliceValue(slice *[]uint64) *uint64SliceValue {
	return &uint64SliceValue{
		value: slice,
	}
}

func (v *uint64SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]uint64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *uint64SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]uint64)(nil)
}

func (v *uint64SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint64Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint64SliceValue) Type() string { return "uint64Slice" }

func (v *uint64SliceValue) IsCumulative() bool {
	return true
}

// -- int Value
type intValue struct {
	value *int
}

var _ Value = (*intValue)(nil)
var _ Getter = (*intValue)(nil)

func newIntValue(p *int) *intValue {
	return &intValue{value: p}
}

func (v *intValue) Set(s string) error {
	parsed, err := strconv.ParseInt(s, 0, 64)
	if err == nil {
		*v.value = (int)(parsed)
		return nil
	}
	return err
}

func (v *intValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *intValue) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *intValue) Type() string { return "int" }

// -- intSlice Value

type intSliceValue struct {
	value   *[]int
	changed bool
}

var _ RepeatableFlag = (*intSliceValue)(nil)
var _ Value = (*intSliceValue)(nil)
var _ Getter = (*intSliceValue)(nil)

func newIntSliceValue(slice *[]int) *intSliceValue {
	return &intSliceValue{
		value: slice,
	}
}

func (v *intSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]int, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}
		out[i] = (int)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *intSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]int)(nil)
}

func (v *intSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIntValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *intSliceValue) Type() string { return "intSlice" }

func (v *intSliceValue) IsCumulative() bool {
	return true
}

// -- int8 Value
type int8Value struct {
	value *int8
}

var _ Value = (*int8Value)(nil)
var _ Getter = (*int8Value)(nil)

func newInt8Value(p *int8) *int8Value {
	return &int8Value{value: p}
}

func (v *int8Value) Set(s string) error {
	parsed, err := strconv.ParseInt(s, 0, 8)
	if err == nil {
		*v.value = (int8)(parsed)
		return nil
	}
	return err
}

func (v *int8Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *int8Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *int8Value) Type() string { return "int8" }

// -- int8Slice Value

type int8SliceValue struct {
	value   *[]int8
	changed bool
}

var _ RepeatableFlag = (*int8SliceValue)(nil)
var _ Value = (*int8SliceValue)(nil)
var _ Getter = (*int8SliceValue)(nil)

func newInt8SliceValue(slice *[]int8) *int8SliceValue {
	return &int8SliceValue{
		value: slice,
	}
}

func (v *int8SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]int8, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}
		out[i] = (int8)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *int8SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]int8)(nil)
}

func (v *int8SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt8Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *int8SliceValue) Type() string { return "int8Slice" }

func (v *int8SliceValue) IsCumulative() bool {
	return true
}

// -- int16 Value
type int16Value struct {
	value *int16
}

var _ Value = (*int16Value)(nil)
var _ Getter = (*int16Value)(nil)

func newInt16Value(p *int16) *int16Value {
	return &int16Value{value: p}
}

func (v *int16Value) Set(s string) error {
	parsed, err := strconv.ParseInt(s, 0, 16)
	if err == nil {
		*v.value = (int16)(parsed)
		return nil
	}
	return err
}

func (v *int16Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *int16Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *int16Value) Type() string { return "int16" }

// -- int16Slice Value

type int16SliceValue struct {
	value   *[]int16
	changed bool
}

var _ RepeatableFlag = (*int16SliceValue)(nil)
var _ Value = (*int16SliceValue)(nil)
var _ Getter = (*int16SliceValue)(nil)

func newInt16SliceValue(slice *[]int16) *int16SliceValue {
	return &int16SliceValue{
		value: slice,
	}
}

func (v *int16SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]int16, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}
		out[i] = (int16)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *int16SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]int16)(nil)
}

func (v *int16SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt16Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *int16SliceValue) Type() string { return "int16Slice" }

func (v *int16SliceValue) IsCumulative() bool {
	return true
}

// -- int32 Value
type int32Value struct {
	value *int32
}

var _ Value = (*int32Value)(nil)
var _ Getter = (*int32Value)(nil)

func newInt32Value(p *int32) *int32Value {
	return &int32Value{value: p}
}

func (v *int32Value) Set(s string) error {
	parsed, err := strconv.ParseInt(s, 0, 32)
	if err == nil {
		*v.value = (int32)(parsed)
		return nil
	}
	return err
}

func (v *int32Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *int32Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *int32Value) Type() string { return "int32" }

// -- int32Slice Value

type int32SliceValue struct {
	value   *[]int32
	changed bool
}

var _ RepeatableFlag = (*int32SliceValue)(nil)
var _ Value = (*int32SliceValue)(nil)
var _ Getter = (*int32SliceValue)(nil)

func newInt32SliceValue(slice *[]int32) *int32SliceValue {
	return &int32SliceValue{
		value: slice,
	}
}

func (v *int32SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]int32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}
		out[i] = (int32)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *int32SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]int32)(nil)
}

func (v *int32SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt32Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *int32SliceValue) Type() string { return "int32Slice" }

func (v *int32SliceValue) IsCumulative() bool {
	return true
}

// -- int64 Value
type int64Value struct {
	value *int64
}

var _ Value = (*int64Value)(nil)
var _ Getter = (*int64Value)(nil)

func newInt64Value(p *int64) *int64Value {
	return &int64Value{value: p}
}

func (v *int64Value) Set(s string) error {
	parsed, err := strconv.ParseInt(s, 0, 64)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *int64Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *int64Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *int64Value) Type() string { return "int64" }

// -- int64Slice Value

type int64SliceValue struct {
	value   *[]int64
	changed bool
}

var _ RepeatableFlag = (*int64SliceValue)(nil)
var _ Value = (*int64SliceValue)(nil)
var _ Getter = (*int64SliceValue)(nil)

func newInt64SliceValue(slice *[]int64) *int64SliceValue {
	return &int64SliceValue{
		value: slice,
	}
}

func (v *int64SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]int64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *int64SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]int64)(nil)
}

func (v *int64SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt64Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *int64SliceValue) Type() string { return "int64Slice" }

func (v *int64SliceValue) IsCumulative() bool {
	return true
}

// -- float64 Value
type float64Value struct {
	value *float64
}

var _ Value = (*float64Value)(nil)
var _ Getter = (*float64Value)(nil)

func newFloat64Value(p *float64) *float64Value {
	return &float64Value{value: p}
}

func (v *float64Value) Set(s string) error {
	parsed, err := strconv.ParseFloat(s, 64)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *float64Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *float64Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *float64Value) Type() string { return "float64" }

// -- float64Slice Value

type float64SliceValue struct {
	value   *[]float64
	changed bool
}

var _ RepeatableFlag = (*float64SliceValue)(nil)
var _ Value = (*float64SliceValue)(nil)
var _ Getter = (*float64SliceValue)(nil)

func newFloat64SliceValue(slice *[]float64) *float64SliceValue {
	return &float64SliceValue{
		value: slice,
	}
}

func (v *float64SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]float64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *float64SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]float64)(nil)
}

func (v *float64SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newFloat64Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *float64SliceValue) Type() string { return "float64Slice" }

func (v *float64SliceValue) IsCumulative() bool {
	return true
}

// -- float32 Value
type float32Value struct {
	value *float32
}

var _ Value = (*float32Value)(nil)
var _ Getter = (*float32Value)(nil)

func newFloat32Value(p *float32) *float32Value {
	return &float32Value{value: p}
}

func (v *float32Value) Set(s string) error {
	parsed, err := strconv.ParseFloat(s, 32)
	if err == nil {
		*v.value = (float32)(parsed)
		return nil
	}
	return err
}

func (v *float32Value) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *float32Value) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%v", *v.value)
	}
	return ""
}

func (v *float32Value) Type() string { return "float32" }

// -- float32Slice Value

type float32SliceValue struct {
	value   *[]float32
	changed bool
}

var _ RepeatableFlag = (*float32SliceValue)(nil)
var _ Value = (*float32SliceValue)(nil)
var _ Getter = (*float32SliceValue)(nil)

func newFloat32SliceValue(slice *[]float32) *float32SliceValue {
	return &float32SliceValue{
		value: slice,
	}
}

func (v *float32SliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]float32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}
		out[i] = (float32)(parsed)
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *float32SliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]float32)(nil)
}

func (v *float32SliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newFloat32Value(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *float32SliceValue) Type() string { return "float32Slice" }

func (v *float32SliceValue) IsCumulative() bool {
	return true
}

// -- time.Duration Value
type durationValue struct {
	value *time.Duration
}

var _ Value = (*durationValue)(nil)
var _ Getter = (*durationValue)(nil)

func newDurationValue(p *time.Duration) *durationValue {
	return &durationValue{value: p}
}

func (v *durationValue) Set(s string) error {
	parsed, err := time.ParseDuration(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *durationValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *durationValue) String() string {
	if v != nil && v.value != nil {
		return (*v.value).String()
	}
	return ""
}

func (v *durationValue) Type() string { return "duration" }

// -- time.DurationSlice Value

type durationSliceValue struct {
	value   *[]time.Duration
	changed bool
}

var _ RepeatableFlag = (*durationSliceValue)(nil)
var _ Value = (*durationSliceValue)(nil)
var _ Getter = (*durationSliceValue)(nil)

func newDurationSliceValue(slice *[]time.Duration) *durationSliceValue {
	return &durationSliceValue{
		value: slice,
	}
}

func (v *durationSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]time.Duration, len(ss))
	for i, s := range ss {
		parsed, err := time.ParseDuration(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *durationSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]time.Duration)(nil)
}

func (v *durationSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newDurationValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *durationSliceValue) Type() string { return "durationSlice" }

func (v *durationSliceValue) IsCumulative() bool {
	return true
}

// -- net.IP Value
type ipValue struct {
	value *net.IP
}

var _ Value = (*ipValue)(nil)
var _ Getter = (*ipValue)(nil)

func newIPValue(p *net.IP) *ipValue {
	return &ipValue{value: p}
}

func (v *ipValue) Set(s string) error {
	parsed, err := parseIP(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *ipValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *ipValue) String() string {
	if v != nil && v.value != nil {
		return v.value.String()
	}
	return ""
}

func (v *ipValue) Type() string { return "ip" }

// -- net.IPSlice Value

type ipSliceValue struct {
	value   *[]net.IP
	changed bool
}

var _ RepeatableFlag = (*ipSliceValue)(nil)
var _ Value = (*ipSliceValue)(nil)
var _ Getter = (*ipSliceValue)(nil)

func newIPSliceValue(slice *[]net.IP) *ipSliceValue {
	return &ipSliceValue{
		value: slice,
	}
}

func (v *ipSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]net.IP, len(ss))
	for i, s := range ss {
		parsed, err := parseIP(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *ipSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]net.IP)(nil)
}

func (v *ipSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIPValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *ipSliceValue) Type() string { return "ipSlice" }

func (v *ipSliceValue) IsCumulative() bool {
	return true
}

// -- HexBytes Value
type hexBytesValue struct {
	value *HexBytes
}

var _ Value = (*hexBytesValue)(nil)
var _ Getter = (*hexBytesValue)(nil)

func newHexBytesValue(p *HexBytes) *hexBytesValue {
	return &hexBytesValue{value: p}
}

func (v *hexBytesValue) Set(s string) error {
	parsed, err := hex.DecodeString(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *hexBytesValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *hexBytesValue) String() string {
	if v != nil && v.value != nil {
		return fmt.Sprintf("%x", *v.value)
	}
	return ""
}

func (v *hexBytesValue) Type() string { return "hexBytes" }

// -- HexBytesSlice Value

type hexBytesSliceValue struct {
	value   *[]HexBytes
	changed bool
}

var _ RepeatableFlag = (*hexBytesSliceValue)(nil)
var _ Value = (*hexBytesSliceValue)(nil)
var _ Getter = (*hexBytesSliceValue)(nil)

func newHexBytesSliceValue(slice *[]HexBytes) *hexBytesSliceValue {
	return &hexBytesSliceValue{
		value: slice,
	}
}

func (v *hexBytesSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]HexBytes, len(ss))
	for i, s := range ss {
		parsed, err := hex.DecodeString(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *hexBytesSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]HexBytes)(nil)
}

func (v *hexBytesSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newHexBytesValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *hexBytesSliceValue) Type() string { return "hexBytesSlice" }

func (v *hexBytesSliceValue) IsCumulative() bool {
	return true
}

// -- *regexp.Regexp Value
type regexpValue struct {
	value **regexp.Regexp
}

var _ Value = (*regexpValue)(nil)
var _ Getter = (*regexpValue)(nil)

func newRegexpValue(p **regexp.Regexp) *regexpValue {
	return &regexpValue{value: p}
}

func (v *regexpValue) Set(s string) error {
	parsed, err := regexp.Compile(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *regexpValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *regexpValue) String() string {
	if v != nil && v.value != nil {
		return (**v.value).String()
	}
	return ""
}

func (v *regexpValue) Type() string { return "regexp" }

// -- *regexp.RegexpSlice Value

type regexpSliceValue struct {
	value   *[]*regexp.Regexp
	changed bool
}

var _ RepeatableFlag = (*regexpSliceValue)(nil)
var _ Value = (*regexpSliceValue)(nil)
var _ Getter = (*regexpSliceValue)(nil)

func newRegexpSliceValue(slice *[]*regexp.Regexp) *regexpSliceValue {
	return &regexpSliceValue{
		value: slice,
	}
}

func (v *regexpSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]*regexp.Regexp, len(ss))
	for i, s := range ss {
		parsed, err := regexp.Compile(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *regexpSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]*regexp.Regexp)(nil)
}

func (v *regexpSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newRegexpValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *regexpSliceValue) Type() string { return "regexpSlice" }

func (v *regexpSliceValue) IsCumulative() bool {
	return true
}

// -- net.TCPAddr Value
type tcpAddrValue struct {
	value *net.TCPAddr
}

var _ Value = (*tcpAddrValue)(nil)
var _ Getter = (*tcpAddrValue)(nil)

func newTCPAddrValue(p *net.TCPAddr) *tcpAddrValue {
	return &tcpAddrValue{value: p}
}

func (v *tcpAddrValue) Set(s string) error {
	parsed, err := parseTCPAddr(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *tcpAddrValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *tcpAddrValue) String() string {
	if v != nil && v.value != nil {
		return v.value.String()
	}
	return ""
}

func (v *tcpAddrValue) Type() string { return "tcpAddr" }

// -- net.TCPAddrSlice Value

type tcpAddrSliceValue struct {
	value   *[]net.TCPAddr
	changed bool
}

var _ RepeatableFlag = (*tcpAddrSliceValue)(nil)
var _ Value = (*tcpAddrSliceValue)(nil)
var _ Getter = (*tcpAddrSliceValue)(nil)

func newTCPAddrSliceValue(slice *[]net.TCPAddr) *tcpAddrSliceValue {
	return &tcpAddrSliceValue{
		value: slice,
	}
}

func (v *tcpAddrSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]net.TCPAddr, len(ss))
	for i, s := range ss {
		parsed, err := parseTCPAddr(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *tcpAddrSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]net.TCPAddr)(nil)
}

func (v *tcpAddrSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newTCPAddrValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *tcpAddrSliceValue) Type() string { return "tcpAddrSlice" }

func (v *tcpAddrSliceValue) IsCumulative() bool {
	return true
}

// -- net.IPNet Value
type ipNetValue struct {
	value *net.IPNet
}

var _ Value = (*ipNetValue)(nil)
var _ Getter = (*ipNetValue)(nil)

func newIPNetValue(p *net.IPNet) *ipNetValue {
	return &ipNetValue{value: p}
}

func (v *ipNetValue) Set(s string) error {
	parsed, err := parseIPNet(s)
	if err == nil {
		*v.value = parsed
		return nil
	}
	return err
}

func (v *ipNetValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return nil
}

func (v *ipNetValue) String() string {
	if v != nil && v.value != nil {
		return v.value.String()
	}
	return ""
}

func (v *ipNetValue) Type() string { return "ipNet" }

// -- net.IPNetSlice Value

type ipNetSliceValue struct {
	value   *[]net.IPNet
	changed bool
}

var _ RepeatableFlag = (*ipNetSliceValue)(nil)
var _ Value = (*ipNetSliceValue)(nil)
var _ Getter = (*ipNetSliceValue)(nil)

func newIPNetSliceValue(slice *[]net.IPNet) *ipNetSliceValue {
	return &ipNetSliceValue{
		value: slice,
	}
}

func (v *ipNetSliceValue) Set(raw string) error {
	ss := strings.Split(raw, ",")

	out := make([]net.IPNet, len(ss))
	for i, s := range ss {
		parsed, err := parseIPNet(s)
		if err != nil {
			return err
		}
		out[i] = parsed
	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true
	return nil
}

func (v *ipNetSliceValue) Get() interface{} {
	if v != nil && v.value != nil {
		return *v.value
	}
	return ([]net.IPNet)(nil)
}

func (v *ipNetSliceValue) String() string {
	if v == nil || v.value == nil {
		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIPNetValue(&elem).String())
	}
	return "[" + strings.Join(out, ",") + "]"
}

func (v *ipNetSliceValue) Type() string { return "ipNetSlice" }

func (v *ipNetSliceValue) IsCumulative() bool {
	return true
}
